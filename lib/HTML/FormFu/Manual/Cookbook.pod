=head1 NAME

HTML::FormFu::Manual::Cookbook - Cooking with HTML::FormFu

=head1 DESCRIPTION

Miscellaneous useful recipes for use with HTML::FormFu

=head1 GETTING STARTED

Some useful info for beginners.

=head2 Installing the TT templates

Before doing anything else, make sure HTML::FormFu's TT templates have been 
set up on your system. This can be done by running this command from your 
commandline:

    html_formfu_deploy.pl <output_path>

The output path will default to "./root" if not specified.

=head2 Default search paths for config and template files

The default locations for config files and templates are as follows:

=head3 Config files

The current working directory (see L<HTML::FormFu/"load_config_file">).

If you're using the C<FormConfig> action attribute from 
L<Catalyst::Controller::HTML::FormFu>, see 
L<Catalyst::Controller::HTML::FormFu/config_file_path>.

=head3 Template files

Subdirectory 'root' of the current working directory. You can supply a 
different template path with the following YAML config:

    render_class_args:
      INCLUDE_PATH: "/path/to/templates"

If you're using L<Catalyst::Controller::HTML::FormFu>, you can ensure 
this is set in all forms by setting this in your C<myapp.yml> Catalyst 
configuration file:

    'Controller::HTML::FormFu':
      constructor:
        render_class_args:
          INCLUDE_PATH: "/path/to/templates"

In this case, C<render_class_args> will be passed to the constructor of 
every form created by the C<Form>, C<FormConfig> and C<FormMethod> 
Catalyst action attributes.

=head2 YAML

Most examples given in the L<HTML::FormFu> documentation use L<YAML> syntax. 
You can use any configuration file type supported by L<Config::Any>, but 
this author's preferred format is YAML.

A form can be populated by a config file by calling 
L<HTML::FormFu/load_config_file> with the filename as an argument. The 
config file is converted to a perl data-structure, and then passed to 
L<HTML::FormFu/populate>.

The config file must contain a hash-ref, with the keys corresponding to 
form method-names, and the values being the method arguments. For example, 
the following are equivalent:

    ---
    auto_fieldset: 1
    elements:
      - name: foo
      - name: bar
    
    # the above YAML is equivalent to the following perl code
    
    $form->auto_fieldset(1);
    
    $form->elements([
        { name => 'foo' },
        { name => 'bar' },
    ]);

When writing your config file, remember that perl hashes are unordered and 
cannot have multiple keys with the same name. 

See L<HTML::FormFu/load_config_file> and L<HTML::FormFu/populate> for 
more details.

See L<http://www.yaml.org/spec/> for the YAML specification.

=head1 BUILDING A FORM

=head2 Quick single-file prototypes

You can run the following script to quickly view a form's markup - replace 
the contents of the C<__DATA__> section with your own YAML config.

It assumes the TT templates are in the './root' directory, see 
L</Installing the FormFu templates> for details.

    #!/usr/bin/perl
    use strict;
    use warnings;
    use HTML::FormFu;
    use YAML::Syck qw( Load );
    
    my $form = HTML::FormFu->new;
    my $yaml = do { local $/; <DATA> };
    my $data = Load($yaml);
    
    $form->populate($data);
    
    print $form;
    
    __DATA__
    ---
    auto_fieldset: 1
    elements:
      - type: Text
        name: foo

=head2 Unsupported HTML tags

You can use the L<HTML::FormFu::Element::Block> element, and set
the L<tag|HTML::FormFu::Element::Block/tag> to create any arbitrary pair of 
tags.

    ---
    elements:
      - type: Block
        tag: span
        content_xml: "<b>Hi!</b>"

You can use L<HTML::FormFu::Element::Block/content>, 
L<HTML::FormFu::Element::Block/content_xml> or 
L<HTML::FormFu::Element::Block/content_loc> to add any content you wish, or 
use L<HTML::FormFu::Element::Block/element> to add elements.

=head1 MODIFYING A FORM

=head2 Insert a new field before existing form fields

See L<HTML::FormFu/insert_before> and L<HTML::FormFu/insert_after>.

    my $fieldset = $form->get_element({ type => 'Fieldset' });
    
    $fieldset->insert_before(
        $form->element(\%specs),
        $form->get_field($name)
    );

Another way to approach the problem is to use multiple config files, and 
decide which to load at runtime:

    # user_edit.yml
    ---
    elements:
      - type: Text
        name: email

    # user_username.yml
    ---
    elements:
      - type: Text
        name: username

     # user_register.yml
     ---
     load_config_file:
      - user_username.yml
      - user_edit.yml

    # create a user edit form, with only the email field
    
    $form->load_config_file( 'user_edit.yml' );
    
    # create a user registration form with username and email fields
    
    $form->load_config_file( 'user_register.yml' );

=head2 From and Field attributes

You can add any arbitrary attributes to a form with 
L<HTML::FormFu/attributes>, or to any element with 
L<HTML::FormFu::Element/attributes>.

    ---
    attributes_xml:
      onsubmit: "js_function()"
    elements:
      - type: Text
        name: foo
        attributes_xml:
          onchange: "js_function()"

=head1 FORM VALIDATION

=head2 Check valid dates

Use L<HTML::FormFu::Inflator::DateTime>. When the inflator is processed, it
will try to create a DateTime object. An error will be returned if the 
supplied values do not make a valid date.

=head2 Check valid URI / URLs

L<HTML::FormFu::Constraint::Regex> supports L<Regexp::Common> regular 
expressions:

    ---
    elements:
        - type: Text
          name: uri
          constraints:
            - type: Regex
              common: [ URI, HTTP, { '-scheme': 'ftp|https?' ]

=head2 Implement a custom constraint / validator

If L<HTML::FormFu::Constraint::Callback> or 
L<HTML::FormFu::Validator::Callback> isn't sufficient for your needs, you 
can create your own class that inherits from L<HTML::FormFu::Constraint> or 
L<HTML::FormFu::Validator>, respectively.

It should implement a C<validate_value> method, which returns true is the 
value is valid, or false otherwise.

    package My::Custom::Validator;
    use strict;
    use warnings;
    use base 'HTML::FormFu::Validator';
    
    sub validate_value {
      my ( $self, $value, $params ) = @_;
      
      return 1 if value_is_valid( $value );
      
      return;
    }
    
    1;

Then add your custom validator to the form:

    ---
    elements:
      - type: Text
        name: foo
        validators:
          - '+My::Custom::Validator'

=head2 Constrain one form field based on the value of another

For example, you have a radiogroup and several text fields, with different text
fields being required depending on the value of the radiogroup.

This is achieved using the C<when> attribute of a constraint:

    constraints:
      - type: Length
        min: 8
        when:
          field: bar
          values: [ 1, 3, 5 ]

In the above example, the Length constraint is only processed when the form
field named "bar" has a value of either 1, 3 or 5.

You can also test for a negative condition using the C<not> attribute:

    constraints:
      - type: Length
        min: 8
        when:
          field: bar
          values: [ 1, 3, 5 ]
          not: 1

Now the constraint will be processed only if the value of field "bar" is NOT 1,
3 or 5.

Both the above attributes are documented further in L<HTML::FormFu::Constraint>.

=head1 HTML MARKUP

=head2 Indented HTML

Use L<HTML::FormFu::OutputProcessor::Indent>:

    ---
    output_processors:
      - Indent

=head2 Add a blank div (e.g. for AJAX purposes)

Simply add a Block element in the relevant place, it defaults to a C<DIV> 
tag.

    ---
    elements:
      - type: Text
        name: user
      
      - type: Block
        id: foo
      
      - type: Text
        name: email

=head1 DISPLAY

=head2 Custom error messages

If you want to display an error message due to an error in your own code, 
such as a database check; something which isn't implemented as a 
L<Constraint|HTML::FormFu::Constraint> or 
L<Validator|HTML::FormFu::Validator>; you can use a
L<Callback Constraint|HTML::FormFu::Constraint::Callback>.

If you don't provide your own callback routine, the default callback will 
always pass, regardless of user input.

You can take advantage of this by setting 
L<force_errors|HTML::FormFu/force_errors>, to display it's error message 
when needed.

Example config:

    ---
    elements:
      - type: Text
      - name: email
      - constraints:
        type: Callback
        message: 'Email address already in use'

Example usage:

	if ( $@ =~ m/duplicate entry for key 'email'/i ) {
        
        $form->get_field('email')
             ->get_constraint('Callback')
             ->force_errors(1);
        
        $form->process;
        # then redisplay the form as normal
    }

=head2 Add a popup hint to a field

Some visual browsers (including IE6/7, Firefox, Opera 9) display a tooltip when
a user hovers their mouse pointer over an HTML element with a "title" tag. Aural
browsers may try to turn the content into speech. You can take advantage of this
behaviour to provide a hint to the user about how to complete a form field.

    elements:
      - type: Text
        name: country_name
        label: Country Name
        attributes:
          title: Name of country

The above will provide a hint when the "country_name" field receives focus. 
Or you could provide the hint for the container tag around both field and label:

    elements:
      - type: Text
        name: country_name
        label: Country Name
        container_attributes:
          title: Name of country

=head2 Display filtered values

If you have a Filter on a field, such as L<HTML::FormFu::Filter::Whitespace> 
to strip leading / trailing whitespace, then if you redisplay the form the 
field is normally populated with the value the user originally entered.

If you would like the field to contain the filtered value, use 
L<HTML::FormFu/render_processed_value>.

=head1 PERFORMANCE

=head2 StackTrace

Are you using L<Catalyst::Plugin::StackTrace>? This is known to 
cause performance problems in combination with L<HTML::FormFu> and 
L<Template>, and we advise disabling it.

=head2 Template::Alloy

You can also use L<Template::Alloy> instead of 
L<Template::Toolkit|Template>, it's mostly compatible, and in many cases 
provides a reasonable speed increase. You can do this either by setting the 
C<HTML_FORMFU_TEMPLATE_ALLOY> environment variable to a true value, or by 
passing C<TEMPLATE_ALLOY> to L<HTML::FormFu/render_class_args>:

    render_class_args:
      TEMPLATE_ALLOY: 1
      COMPILE_DIR: /tmp
      COMPILE_PERL: 1

Template::Alloy's caching is off by default. Switch it on by setting either 
C<COMPILE_EXT> or C<COMPILE_DIR>. If you're running under a persistent 
environment such as modperl or fastcgi, you should also set C<COMPILE_PERL> 
to compile the cached templates down to perl code.

Of cource, if you wish you can still use L<Template::Toolkit|Template> to 
process your own application templates, letting L<Template::Alloy> process 
just the HTML::FormFu templates.

=head2 HTML:FormFu::Preload

To reduce the runtime for each form that uses a previously unused
element or processor - at the expense of greater memory usage - you 
can preload all FormFu modules - this is only recommended for persistent 
environments such as modperl or fastcgi:

    use HTML::FormFu::Preload;

=head1 FAQs

=head2 Force an element to always have a certain value

See the following:

L<HTML::FormFu::Element::_Field/"retain_default">, 
L<HTML::FormFu::Element::_Field/"force_default">

=head1 AUTHORS

Will Hawes C<wdhawes@gmail.com>

Carl Franks C<cfranks@cpan.org>

=head1 COPYRIGHT

This document is free, you can redistribute it and/or modify it
under the same terms as Perl itself.
